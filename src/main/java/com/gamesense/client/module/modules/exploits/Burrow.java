package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.setting.values.ModeSetting;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Module.Declaration(
    name = "Burrow",
    category = Category.Exploits
)
public class Burrow extends Module {

    private static final String NULL_POINTER = "NullPointerException";
    private static final String CONCURRENT_MODIFICATION = "ConcurrentModification";
    private static final String CLASS_CAST = "ClassCastException";
    private static final String ARITHMETIC = "ArithmeticException";
    private static final String ARRAY_INDEX_OUT_OF_BOUNDS = "ArrayIndexOutOfBoundsException";
    private static final String NUMBER_FORMAT = "NumberFormatException";
    private static final String ILLEGAL_ARGUMENT = "IllegalArgumentException";
    private static final String CLASS_NOT_FOUND = "ClassNotFoundException";
    private static final String STACK_OVERFLOW = "StackOverflowError";

    private final ModeSetting mode = registerMode(
        "Mode",
        Arrays.asList(
            NULL_POINTER,
            CONCURRENT_MODIFICATION,
            CLASS_CAST,
            ARITHMETIC,
            ARRAY_INDEX_OUT_OF_BOUNDS,
            NUMBER_FORMAT,
            ILLEGAL_ARGUMENT,
            CLASS_NOT_FOUND,
            STACK_OVERFLOW
        ),
        NULL_POINTER
    );

    @Override
    protected void onEnable() {
        disable();

        if (mc.player != null) {
            switch (mode.getValue()) {
                case NULL_POINTER:
                    npe();
                    break;
                case CONCURRENT_MODIFICATION:
                    cme();
                    break;
                case CLASS_CAST:
                    cce();
                    break;
                case ARITHMETIC:
                    ae();
                    break;
                case ARRAY_INDEX_OUT_OF_BOUNDS:
                    aiooe();
                    break;
                case NUMBER_FORMAT:
                    nfe();
                    break;
                case ILLEGAL_ARGUMENT:
                    iae();
                    break;
                case CLASS_NOT_FOUND:
                    cnfe();
                    break;
                case STACK_OVERFLOW:
                    soe();
                    break;
                default:
                    break;
            }
        }
    }

    @SuppressWarnings({"ResultOfMethodCallIgnored", "ConstantConditions"})
    private void npe() {
        String a = null;
        assert a != null;
        a.length();
    }

    private void cme() {
        List<Integer> list = new ArrayList<>();
        list.add(69);
        list.add(420);
        list.add(911);
        list.add(404);
        list.add(69420);
        for (Integer element : list) {
            list.remove(element);
        }
    }

    private void cce() {
        ((Iterable<?>) this).iterator();
    }

    @SuppressWarnings("divzero")
    private void ae() {
        int a = 69420;
        int b = 0;
        int c = a / b;
        System.out.println(c);
    }

    @SuppressWarnings({"MismatchedReadAndWriteOfArray", "ConstantConditions"})
    private void aiooe() {
        int[] a = new int[0];
        System.out.println(a[911]);
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private void nfe() {
        Integer.parseInt("lmfao");
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private void iae() {
        int[] array = new int[] {69, 420, 911};
        Arrays.copyOfRange(array, 1, 0);
    }

    private void cnfe() {
        try {
            Method method = Class.class.getMethod("forName", String.class);
            method.invoke(null, "lol.trolled.69420");
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException troll) {
            // To bypass the error and let it throw ClassNotFoundException
        }
    }

    @SuppressWarnings("InfiniteRecursion")
    private void soe() {
        System.out.println("kek");
        soe();
    }
}
