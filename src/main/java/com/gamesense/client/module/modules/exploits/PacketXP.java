package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.setting.Setting;
import com.gamesense.client.module.Module;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketPlayer;

import java.util.ArrayList;

/**
 * @author Hoosiers
 * @since 12/14/2020
 */

public class PacketXP extends Module {

    public PacketXP() {
        super("PacketXP", Category.Exploits);
    }

    Setting.Integer minDamage;
    Setting.Integer maxHeal;
    Setting.Boolean noEntityCollision;
    Setting.Boolean sneakOnly;

    public void setup() {
        sneakOnly = registerBoolean("Sneak Only", true);
        noEntityCollision = registerBoolean("No Collision", true);
        minDamage = registerInteger("Min Damage", 50, 1, 100);
        maxHeal = registerInteger("Repair To", 90, 1, 100);
    }

    ArrayList<ItemStack> toMend = new ArrayList<>();

    public void onUpdate() {
        if (mc.player == null || mc.world == null || mc.player.ticksExisted < 10) {
            return;
        }

        for (ItemStack itemStack : mc.player.inventory.armorInventory) {
            if (itemStack.isEmpty) {
                continue;
            }

            //this works better than my calculation for some reason, thank you ArmorHUD.java
            float damagePercent1 = 1 - ((itemStack.getMaxDamage() - itemStack.getItemDamage()) / itemStack.getMaxDamage());
            float damagePercent2 = 100 - (100 * damagePercent1);

            if (damagePercent2 <= minDamage.getValue() && !toMend.contains(itemStack)) {
                toMend.add(itemStack);
            }

            if (damagePercent2 >= maxHeal.getValue() && toMend.contains(itemStack)) {
                toMend.remove(itemStack);
            }
        }

        if (toMend.size() > 0) {
            mendArmor(mc.player.inventory.currentItem);
        }
    }

    private void mendArmor(int oldSlot) {
        if (noEntityCollision.getValue()) {
            for (EntityPlayer entityPlayer : mc.world.playerEntities) {
                if (entityPlayer.getDistance(mc.player) < 1 && entityPlayer != mc.player) {
                    return;
                }
            }
        }

        if (sneakOnly.getValue() && !mc.player.isSneaking()) {
            return;
        }

        int newSlot = findXPSlot();

        if (newSlot == -1) {
            return;
        }

        if (oldSlot != newSlot) {
            mc.player.inventory.currentItem = newSlot;
        }

        mc.player.connection.sendPacket(new CPacketPlayer.Rotation(0, 90, true));
        mc.rightClickMouse();
        mc.player.inventory.currentItem = oldSlot;
    }

    private int findXPSlot() {
        int slot = -1;

        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() == Items.EXPERIENCE_BOTTLE) {
                slot = i;
                break;
            }
        }

        return slot;
    }
}