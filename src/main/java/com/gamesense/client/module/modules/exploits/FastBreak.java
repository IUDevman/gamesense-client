package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.Phase;
import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.event.events.OnUpdateWalkingPlayerEvent;
import com.gamesense.api.event.events.RenderEvent;
import com.gamesense.api.setting.values.*;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.player.PlayerPacket;
import com.gamesense.api.util.player.RotationUtil;
import com.gamesense.api.util.render.GSColor;
import com.gamesense.api.util.render.RenderUtil;
import com.gamesense.api.util.world.BlockUtil;
import com.gamesense.api.util.world.GeometryMasks;
import com.gamesense.client.manager.managers.PlayerPacketManager;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.modules.combat.CevBreaker;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;

import java.util.Arrays;

/*
    @author: TechAle and Hossier
    last edit 06/04/21
 */

/**
 * Thanks to:
 * A special thank to Kami147 for making this exploit public
 * https://github.com/Kami147/InstantMine/blob/main/InstantMine.java
 */

@Module.Declaration(name = "FastBreak", category = Category.Exploits, priority = 250)
public class FastBreak extends Module {

    ModeSetting mode = registerMode("Mode", Arrays.asList("Packet", "Damage", "Instant", "Breaker"), "Packet");
    DoubleSetting startDamage = registerDouble("Start Damage", 0.1, 0, 1);
    DoubleSetting endDamage = registerDouble("End Damage", 0.9, 0, 1);
    BooleanSetting haste = registerBoolean("Haste", false);
    BooleanSetting switchPick = registerBoolean("Switch Pick", false);
    BooleanSetting switchBack = registerBoolean("Switch Back", true);
    BooleanSetting spammer = registerBoolean("Spammer", false);
    BooleanSetting ignoreChecks = registerBoolean("Ignore Checks", false);
    BooleanSetting onlyOnPick = registerBoolean("Only On Pick", false);
    BooleanSetting startPick = registerBoolean("Start Pick", false);
    IntegerSetting resetTickDestroy = registerInteger("Tick Reset Destroy", 0, 0, 50);
    IntegerSetting pickTickSwitch = registerInteger("Pick Switch Destroy", 75, 0, 90);
    IntegerSetting pickStill = registerInteger("Pick Switch Still", 20, 0, 30);
    IntegerSetting spammerTickDelay = registerInteger("Spammer Delay", 0, 0, 20);
    IntegerSetting breakerTickDelay = registerInteger("Breaker Delay", 0, 0, 20);
    BooleanSetting forceRotation = registerBoolean("Force Rotation", false);
    IntegerSetting rangeDisableBreaker = registerInteger("Range Disable Breaker", 15, 6, 50);
    BooleanSetting display = registerBoolean("Display", false);
    ColorSetting blockColor = registerColor("Block Color", new GSColor(102, 51, 153));
    ModeSetting renderMode = registerMode("Render", Arrays.asList("Outline", "Fill", "Both"), "Both");
    IntegerSetting width = registerInteger("Width", 1, 1, 10);
    private int tick = 99;
    private int tickSpammer = 0;
    private int oldslot;
    private int breakTick = 0;
    private int wait = 100;


    private BlockPos lastBlock = null;
    private boolean pickStillBol = false;
    private EnumFacing direction;
    private boolean minedBefore = false;
    private int reseTick;

    private Vec3d lastHitVec = null;
    @EventHandler
    private final Listener<OnUpdateWalkingPlayerEvent> onUpdateWalkingPlayerEventListener = new Listener<>(event -> {
        if (event.getPhase() != Phase.PRE || lastHitVec == null || !forceRotation.getValue() || lastBlock == null) return;
        Vec2f rotation = RotationUtil.getRotationTo(lastHitVec);
        PlayerPacket packet = new PlayerPacket(this, rotation);
        PlayerPacketManager.INSTANCE.addPacket(packet);
    });

    public void onUpdate() {
        /*
            So, this is a little bit complex.
            I want to use the same things for every switch we will ever encounter, both with switch or switchback or switch still
            So, tick = 99 is when we have done
         */
        if (tick != 99) {
            // Simple timer
            if (tick++ >= wait) {
                // Save slot in case of switch back
                int prev = mc.player.inventory.currentItem;
                // If oldslot != -1 (who know, i dont wanna random crashes)
                if (oldslot != -1) {
                    // Change
                    mc.player.inventory.currentItem = oldslot;
                    oldslot = -1;
                }
                // If we have to change
                if (!pickStillBol) {
                    // So, in case we have to switch back
                    if (pickTickSwitch.getValue() != 0 && switchPick.getValue()) {
                        // New wait
                        wait = pickStill.getValue();
                        // Reset tick
                        tick = 0;
                        // New oldslot
                        oldslot = prev;
                        // do not enter this if again basically
                        pickStillBol = true;
                    } else {
                        // Else, just finish
                        tick = 99;
                        mc.player.inventory.currentItem = prev;
                    }
                // Just finish in case we have not to switch
                } else
                    tick = 99;
            }
        }

        // This is for making breaker working
        Minecraft.getMinecraft().playerController.blockHitDelay = 0;
        mc.playerController.blockHitDelay = 0;

        if (haste.getValue()) {
            PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
            mc.player.addPotionEffect(new PotionEffect(effect));
        }
        if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        /*
            So, we have a lot of options and i tried to keep everything united.
            The first if, enter only if: Or we have a pick on the mainhand, or we have choose that we can do everything even without pick
         */
        if (!onlyOnPick.getValue() || mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe)
            // The second check for breaker, if cevBreaker allow us to use breaker
            if ((mode.getValue().equals("Breaker") && !CevBreaker.isPossible) || CevBreaker.forceBrk) {
                // The second, first check if we have a lastblock, if yes, it's just a timer
                if (lastBlock != null && ((spammer.getValue() && tickSpammer++ >= spammerTickDelay.getValue()))) {
                    // Reset timer
                    tickSpammer = 0;
                    // If we have mined it before
                    if (minedBefore) {
                        if (resetTickDestroy.getValue() != 0 && reseTick++ >= resetTickDestroy.getValue() && !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) {
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, lastBlock, direction));
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastBlock, direction));
                            reseTick = 0;
                            minedBefore = false;
                            return;
                        }
                        // Here, we check if it's air in case we have choose to not spam it every time
                        if (ignoreChecks.getValue() || !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) {
                            // Get distance, if it's >=, then delete it
                            if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue())
                                lastBlock = null;
                            else {
                                // Finally break it
                                breakerBreak();
                            }
                        }
                    // This is for checking if it's air, if yes, then we have mined it (maybe)
                    } else if (BlockUtil.getBlock(lastBlock) instanceof BlockAir) {
                        minedBefore = true;
                        reseTick = 0;
                    }
                }
            }
    }

    // Actual function for breaker, this is used by both update and event
    private void breakerBreak() {
        // Get item
        Item item = mc.player.inventory.getCurrentItem().getItem();
        // OldSlot
        int oldSlot = -1;
        // Switch to pick
        if (!(item instanceof ItemPickaxe) && minedBefore && (switchBack.getValue() || switchPick.getValue())) {
            oldSlot = mc.player.inventory.currentItem;
            int slot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            // Who know? Do you want to get kicked?
            if (slot != -1)
                mc.player.inventory.currentItem = slot;
        }
        // Send STOP_DESTROY_BLOCK
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                lastBlock, direction));
        // If oldSlot != -1, so we have switchback
        if (oldSlot != -1 && switchBack.getValue()) {
            // Allow to switchback
            tick = 0;
            oldslot = oldSlot;
            // Since we use it for both packet and breaker, we have to do these checks
            if (!minedBefore || (mode.getValue().equals("Packet") && !CevBreaker.forceBrk)) {
                wait = pickTickSwitch.getValue();
                pickStillBol = !switchBack.getValue();
            }
            else
                wait = pickStill.getValue();
        }

    }

    // Listener of damageblockevent
    @EventHandler
    private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

        if (mc.world == null || mc.player == null) return;
        if (!canBreak(event.getBlockPos()) || event.getBlockPos() == null) return;

        if (CevBreaker.forceBrk) {
            breakerAlgo(event);
            return;
        }

        if (forceRotation.getValue())
            setVec3d(event.getBlockPos(), event.getEnumFacing());

        switch (mode.getValue()) {
            case "Packet" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                event.cancel();
                lastBlock = event.getBlockPos();
                oldslot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
                tick = 0;
                wait = pickTickSwitch.getValue();
                pickStillBol = false;
                break;
            }
            case "Damage" : {
                if (mc.playerController.curBlockDamageMP < startDamage.getValue())
                    mc.playerController.curBlockDamageMP = startDamage.getValue().floatValue();

                if (mc.playerController.curBlockDamageMP >= endDamage.getValue()) {
                    mc.playerController.curBlockDamageMP = 1.0f;
                }
                break;
            }
            case "Instant" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
                mc.world.setBlockToAir(event.getBlockPos());
                break;
            }
            case "Breaker" : {
                breakerAlgo(event);
                break;
            }
        }
    });

    private void setVec3d(BlockPos pos, EnumFacing side) {
        BlockPos neighbour = pos.offset(side);
        EnumFacing opposite = side.getOpposite();
        lastHitVec = new Vec3d(neighbour).add(0.5, 0.5, 0.5).add(new Vec3d(opposite.getDirectionVec()).scale(0.5));
    }

    // Algo for breaker when first launched, this is heavely modified from ciru's instabreaker
    private void breakerAlgo(DamageBlockEvent event) {
        // Checks if we have already entered here
        if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
            if (startPick.getValue()) {
                int pick = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
                if (pick != -1)
                    mc.player.inventory.currentItem = pick;
            }
            // Start breaking normally
            minedBefore = false;
            mc.player.swingArm(EnumHand.MAIN_HAND);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
            lastBlock = event.getBlockPos();
            direction = event.getEnumFacing();
        }
        // This is a simple timer in case we want to limit the packets during cevbreaker
        if (breakerTickDelay.getValue() <= breakTick++) {
            // Algo Breaker
            breakerBreak();
            event.cancel();
            breakTick = 0;
        }
        // Switch to pick, dont run if cevbreaker
        if (!CevBreaker.isActive && switchPick.getValue()) {
            oldslot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            tick = 0;
            wait = pickTickSwitch.getValue();
            pickStillBol = !switchBack.getValue();
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public void onDisable() {
        if (haste.getValue()) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        breakTick = 0;
    }

    public void onWorldRender(RenderEvent event) {
        if (lastBlock != null)
            if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue()) {
                lastBlock = null;
            } else if (display.getValue()) {
                if (mode.getValue().equals("Breaker") || CevBreaker.forceBrk || (mode.getValue().equals("Packet") && !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) || (mode.getValue().equals("Packer")))
                    renderBox(lastBlock);
                else lastBlock = null;
            }
    }

    // Render box
    private void renderBox(BlockPos blockPos) {
        GSColor gsColor1 = new GSColor(blockColor.getValue(), 255);
        GSColor gsColor2 = new GSColor(blockColor.getValue(), 50);

        switch (renderMode.getValue()) {
            case "Both": {
                RenderUtil.drawBox(blockPos, 1, gsColor2, GeometryMasks.Quad.ALL);
                RenderUtil.drawBoundingBox(blockPos, 1, width.getValue(), gsColor1);
                break;
            }
            case "Outline": {
                RenderUtil.drawBoundingBox(blockPos, 1, width.getValue(), gsColor1);
                break;
            }
            case "Fill": {
                RenderUtil.drawBox(blockPos, 1, gsColor2, GeometryMasks.Quad.ALL);
                break;
            }
            default: {
                break;
            }
        }
    }
}