package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.setting.values.DoubleSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.setting.values.ModeSetting;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.world.BlockUtil;
import com.gamesense.client.GameSense;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.modules.combat.CevBreaker;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.util.Arrays;

/**
 * A special thank to Kami147 for making this exploit public
 * https://github.com/Kami147/InstantMine/blob/main/InstantMine.java
 */

@Module.Declaration(name = "FastBreak", category = Category.Exploits)
public class FastBreak extends Module {

    ModeSetting mode = registerMode("Mode", Arrays.asList("Packet", "Damage", "Instant", "Breaker"), "Packet");
    DoubleSetting startDamage = registerDouble("Start Damage", 0.1, 0, 1);
    DoubleSetting endDamage = registerDouble("End Damage", 0.9, 0, 1);
    BooleanSetting haste = registerBoolean("Haste", false);
    BooleanSetting switchPick = registerBoolean("Switch Pick", false);
    BooleanSetting switchBack = registerBoolean("Switch Back", true);
    BooleanSetting spammer = registerBoolean("Spammer", false);
    IntegerSetting pickTickSwitch = registerInteger("Pick Switch", 0, 0, 20);
    IntegerSetting spammerTickDelay = registerInteger("Spammer Delay", 0, 0, 20);
    IntegerSetting breakerTickDelay = registerInteger("Breaker Delay", 0, 0, 20);
    private int tick = 99;
    private int tickSpammer = 0;
    private int oldslot;
    private int breakTick = 0;


    private BlockPos lastBlock = null;
    private boolean packetCancel = false;
    private EnumFacing direction;
    private BlockPos blockAimed;

    public void onUpdate() {

        if (tick != 99) {
            if (tick++ == pickTickSwitch.getValue()) {
                mc.player.inventory.currentItem = oldslot;
                tick = 99;
            }
        }

        // This is for making breaker working
        Minecraft.getMinecraft().playerController.blockHitDelay = 0;
        mc.playerController.blockHitDelay = 0;

        if (haste.getValue()) {
            PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
            mc.player.addPotionEffect(new PotionEffect(effect));
        }
        if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }

        if (mode.getValue().equals("Breaker") && !CevBreaker.isActive) {
            if (lastBlock != null && ((spammer.getValue() && tickSpammer++ == spammerTickDelay.getValue()) || !(BlockUtil.getBlock(lastBlock) instanceof BlockAir))) {
                breakerBreak();
                tickSpammer = 0;
            }
        }
    }

    private void breakerBreak() {
        Item item;
        int oldSlot = -1;
        if ((item = mc.player.inventory.getCurrentItem().getItem()) instanceof ItemPickaxe || switchPick.getValue()) {
            if (!(item instanceof ItemPickaxe)) {
                oldSlot = mc.player.inventory.currentItem;
                mc.player.inventory.currentItem = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            }
            // Send STOP_DESTROY_BLOCK
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    lastBlock, direction));
            if (oldslot != -1 && switchBack.getValue()) {
                tick = 0;
            }

            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastBlock, direction));
            if (oldSlot != -1 && switchBack.getValue()) {
                mc.player.inventory.currentItem = oldSlot;
            }
        }
    }

    @EventHandler
    private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

        if (mc.world == null || mc.player == null) return;
        if (!canBreak(event.getBlockPos()) || event.getBlockPos() == null) return;

        switch (mode.getValue()) {
            case "Packet" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                event.cancel();
                break;
            }
            case "Damage" : {
                if (mc.playerController.curBlockDamageMP < startDamage.getValue())
                    mc.playerController.curBlockDamageMP = startDamage.getValue().floatValue();

                if (mc.playerController.curBlockDamageMP >= endDamage.getValue()) {
                    mc.playerController.curBlockDamageMP = 1.0f;
                }
                break;
            }
            case "Instant" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
                mc.world.setBlockToAir(event.getBlockPos());
                break;
            }
            case "Breaker" : {
                blockAimed = event.getBlockPos();
                if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                    lastBlock = event.getBlockPos();
                    direction = event.getEnumFacing();
                }
                if (breakerTickDelay.getValue() <= breakTick) {
                    breakerBreak();
                    event.cancel();
                    breakTick = 0;
                } else {
                    breakTick++;
                }
                break;
            }
        }
    });

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public void onDisable() {
        if (haste.getValue()) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        breakTick = 0;
    }
}