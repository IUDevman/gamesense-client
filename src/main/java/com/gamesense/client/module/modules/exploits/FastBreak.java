package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.event.events.RenderEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.setting.values.ColorSetting;
import com.gamesense.api.setting.values.DoubleSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.setting.values.ModeSetting;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.render.GSColor;
import com.gamesense.api.util.render.RenderUtil;
import com.gamesense.api.util.world.BlockUtil;
import com.gamesense.api.util.world.GeometryMasks;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.modules.combat.CevBreaker;
import java.util.Arrays;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

/*
    @Author: TechAle and Hossier
 */

/**
 * Thanks to:
 * A special thank to Kami147 for making this exploit public
 * https://github.com/Kami147/InstantMine/blob/main/InstantMine.java
 */

@Module.Declaration(name = "FastBreak", category = Category.Exploits)
public class FastBreak extends Module {

    ModeSetting mode = registerMode("Mode", Arrays.asList("Packet", "Damage", "Instant", "Breaker"), "Packet");
    DoubleSetting startDamage = registerDouble("Start Damage", 0.1, 0, 1);
    DoubleSetting endDamage = registerDouble("End Damage", 0.9, 0, 1);
    BooleanSetting haste = registerBoolean("Haste", false);
    BooleanSetting switchPick = registerBoolean("Switch Pick", false);
    BooleanSetting switchBack = registerBoolean("Switch Back", true);
    BooleanSetting spammer = registerBoolean("Spammer", false);
    IntegerSetting pickTickSwitch = registerInteger("Pick Switch", 0, 0, 20);
    IntegerSetting spammerTickDelay = registerInteger("Spammer Delay", 0, 0, 20);
    IntegerSetting breakerTickDelay = registerInteger("Breaker Delay", 0, 0, 20);
    IntegerSetting rangeDisableBreaker = registerInteger("Range Disable Breaker", 15, 6, 50);
    BooleanSetting display = registerBoolean("Display", false);
    ColorSetting blockColor = registerColor("Block Color", new GSColor(102, 51, 153));
    ModeSetting renderMode = registerMode("Render", Arrays.asList("Outline", "Fill", "Both"), "Both");
    IntegerSetting width = registerInteger("Width", 1, 1, 10);
    private int tick = 99;
    private int tickSpammer = 0;
    private int oldslot;
    private int breakTick = 0;


    private BlockPos lastBlock = null;
    private final boolean packetCancel = false;
    private EnumFacing direction;
    private BlockPos blockAimed;
    @EventHandler
    private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

        if (mc.world == null || mc.player == null) return;
        if (!canBreak(event.getBlockPos()) || event.getBlockPos() == null) return;

        switch (mode.getValue()) {
            case "Packet" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                event.cancel();
                lastBlock = event.getBlockPos();
                break;
            }
            case "Damage" : {
                if (mc.playerController.curBlockDamageMP < startDamage.getValue())
                    mc.playerController.curBlockDamageMP = startDamage.getValue().floatValue();

                if (mc.playerController.curBlockDamageMP >= endDamage.getValue()) {
                    mc.playerController.curBlockDamageMP = 1.0f;
                }
                break;
            }
            case "Instant" : {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
                mc.world.setBlockToAir(event.getBlockPos());
                break;
            }
            case "Breaker" : {
                blockAimed = event.getBlockPos();
                if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                    lastBlock = event.getBlockPos();
                    direction = event.getEnumFacing();
                }
                if (breakerTickDelay.getValue() <= breakTick) {
                    breakerBreak();
                    event.cancel();
                    breakTick = 0;
                } else {
                    breakTick++;
                }
                break;
            }
        }
    });

    public void onUpdate() {

        if (tick != 99) {
            if (tick++ == pickTickSwitch.getValue()) {
                mc.player.inventory.currentItem = oldslot;
                tick = 99;
            }
        }

        // This is for making breaker working
        Minecraft.getMinecraft().playerController.blockHitDelay = 0;
        mc.playerController.blockHitDelay = 0;

        if (haste.getValue()) {
            PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
            mc.player.addPotionEffect(new PotionEffect(effect));
        }
        if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }

        if (mode.getValue().equals("Breaker") && !CevBreaker.isPossible) {
            if (lastBlock != null && ((spammer.getValue() && tickSpammer++ == spammerTickDelay.getValue()) || !(BlockUtil.getBlock(lastBlock) instanceof BlockAir))) {
                if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue())
                    lastBlock = null;
                else {
                    breakerBreak();
                    tickSpammer = 0;
                }
            }
        }
    }

    private void breakerBreak() {
        Item item;
        int oldSlot = -1;
        if ((item = mc.player.inventory.getCurrentItem().getItem()) instanceof ItemPickaxe || switchPick.getValue()) {
            if (!(item instanceof ItemPickaxe)) {
                oldSlot = mc.player.inventory.currentItem;
                mc.player.inventory.currentItem = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            }
            // Send STOP_DESTROY_BLOCK
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    lastBlock, direction));
            if (oldslot != -1 && switchBack.getValue()) {
                tick = 0;
            }

            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastBlock, direction));
            if (oldSlot != -1 && switchBack.getValue()) {
                mc.player.inventory.currentItem = oldSlot;
            }
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public void onDisable() {
        if (haste.getValue()) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        breakTick = 0;
    }

    public void onWorldRender(RenderEvent event) {
        if (lastBlock != null)
            if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue()) {
                lastBlock = null;
            } else if (display.getValue()) {
                if (mode.getValue().equals("Breaker") || (mode.getValue().equals("Packet") && !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)))
                    renderBox(lastBlock);
                else lastBlock = null;
            }
    }


    private void renderBox(BlockPos blockPos) {
        GSColor gsColor1 = new GSColor(blockColor.getValue(), 255);
        GSColor gsColor2 = new GSColor(blockColor.getValue(), 50);

        switch (renderMode.getValue()) {
            case "Both": {
                RenderUtil.drawBox(blockPos, 1, gsColor2, GeometryMasks.Quad.ALL);
                RenderUtil.drawBoundingBox(blockPos, 1, width.getValue(), gsColor1);
                break;
            }
            case "Outline": {
                RenderUtil.drawBoundingBox(blockPos, 1, width.getValue(), gsColor1);
                break;
            }
            case "Fill": {
                RenderUtil.drawBox(blockPos, 1, gsColor2, GeometryMasks.Quad.ALL);
                break;
            }
            default: {
                break;
            }
        }
    }
}